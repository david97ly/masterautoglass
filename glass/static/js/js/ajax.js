/ *! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license * /
! Función (a, b) {"objeto" == módulo typeof && "objeto" == typeof module.exports module.exports = a.document b (a, 0!):?! Función (a) {if (a .document) throw new Error ("jQuery requiere una ventana con un documento"); b retorno (a)}:!? b (a)} ("undefined" = ventana typeof ventana: esto, la función (a, b) { var nuevo d.call (este)}, obtener: function (a) {return null = a 0> a esto [a + this.length]:?!? esta [a]: d.call (este)}, pushStack: función (a) {var b = n.merge (this.constructor (), a); volver b.prevObject = este, b.context = this.context, b}, cada uno: la función (a, b) {return n. cada uno (esto, a, b)}, el mapa: function (a) {return this.pushStack (n.map (esto, la función (b, c) {return a.call (b, c, b)}))} , rebanada: function () {return this.pushStack (d.apply (este, argumentos))}, primero: function () {return this.eq (0)}, última: function () {return this.eq (- 1)}, eq: function (a) {var b = this.length, c = + a + (0> a b:? 0); volver this.pushStack (c> = 0 && b> c [este [c]] : [])}, final: function () {return a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j = 1;! a ("booleano" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "objeto" == typeof g || n.isFunction (g) || (g = {}), h === i && (g = este, h -); i> h; h ++) si (null = (a = argumentos [h])) de (b en! == 0 && d (g [b] = D)); retorno g}, n.extend ({expando: "jQuery" + (m + Math.random ())! Reemplazar (/ \ D / g, "". ), isReady: 0, error: function (a) {throw new b; para (b en a) devuelve 1; devolver 0}, tipo: función (a) {return null == a a + "": "objeto" == typeof a || "función" == typeof una!? ? h [i.call (a)] || "objeto": typeof a}, globalEval: function (a) {var b, c = eval; a = n.trim (a), una && (1 === una .indexOf ("uso a.replace (p, "ms -") reemplazar (q, r)}, nodeName:. función (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada : function (a, b, c) {var d, e = 0, f = a.length, g = s (a), si (c) {if (g) {for (; f> e; e ++) si (d = b.apply (a [e], c), d ===! 1) Salto} else para (e en a) si (d = b.apply (a [e], c), d == ! = 1) Salto} else if (g) {for (; f> e; e ++) si (d = b.call (a [e], e, a [e])!, d === 1) Salto } else para (e en a) si (d = b.call (a [e], e, a [e]), d === 1!) rompa; volver a}, recorte: función (a) {return nula == un "" :( a + "") reemplazar (o, "")}, MakeArray:?.! función (a, b) {var c = b || []; devolver null && = a (s (Object ? (a)) n.merge (c, "cadena" == typeof un [a]: a): f.call (c, a)), c}, InArray: function (a, b c,) { devolver null == b -1: g.call (b, a, c)}, fusión: function (a, b) {for (var c = + b.length, d = 0, e = a.length;? c> d; d ++) a [e ++] = b [d]; retorno a.length = e, a}, grep: function (a, b, c) {for (var d, e = [], f = 0 , g = a.length, h = c;! g> f; f ++) d = b (a [f], f), d == h && e.push (a [f]);! devolución e}, mapa :; si (h) para (; g> f; f ++) d = function (a, b, c) {var d, f = 0, g = a.length, h = (a), i = [] s b (a [f], f, c), d null = && i.push (d);!! else para (f en a) d = b (a [f], f, c), d null = && i.push ( d); volver e.apply ([], i)}, guid: 1, delegación: function (a, b) {var c, e, f, vuelvo "cadena" == typeof b && (c = a [b] , b = a, a = c), n.isFunction (a)? (e = d.call (argumentos, 2), f = function () {return a.apply (b || esto, e.concat (d .call (argumentos)))}, f.guid = a.guid = a.guid || n.guid ++, f): void 0}, ahora: Date.now, soporte: k}), n.each (" Número de Boole Cadena función array Fecha RegExp objeto Error ".split (" "), la función (a, b) {h [" [objeto "+ b +"] "] = b.toLowerCase ()}); función s (a) {var b && b> 0 && b-1 en una} var t = function (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r , s, t, u = "chisporroteo" + - nuevo Fecha, v = a.document, w = 0, x = 0, y = gb (), z = gb (), A = gb (), B = function (a, b) {return b = 0, c = this.length; c> b; b ++) si (esta [b] === a) la devolución RegExp ("^" + M + "+ | ((:??. ^ | [^ \\\\]) (: \\\\) *)" + M + "+ $", "g"), S = nueva RegExp ("^" + M + "*" + M + "*"), T = new RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*") , U = new RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), V = new RegExp (Q), W = new RegExp ("^" + O + "$"), X = {ID: nueva RegExp ("^ # (" + N + ")"), CLASE: nueva RegExp (". ^ \\ (" + N + ") "), TAG: nueva RegExp (" ^ ("+ N.replace (" w "," w * ") +") "), ATTR: nueva RegExp (" ^ "+ P), PSEUDO: nueva RegExp (" ^ "+ Q), NIÑO: nuevo RegExp ("^ (?:" + "$)" L + "i"), needsContext: nuevo \ W /, _ = / ^ (?: # ([\ W -] +) | (\ w +) | \ ([\ w -] +).) $ /, Ab = / [+ ~] /, bb = / '| \\ / g, cb = new RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "|? (" + M + ") |.)", " ig "), db = function (a, b, c) {var d =" 0 x "+ b-65536; retorno c = a.length, d = 0, mientras que (a [c ++] = b [d ++]); a.length = c-1}}} fb función (a, b, d, e) {var f, h, j, k, l, o, r, s, w, x; if ((b b.ownerDocument || b:?! v) == n && m (b), b = b || n, d = d || [] ,! a || "cadena"! = typeof a) la devolución d; si (h.id === j) la devolución d.push (h), d} else if (b.ownerDocument && (h = b.ownerDocument.getElementById (j)) && t (b, h) && h.id = == j) la devolución d.push (h), d} else {if (f [2]) return I.apply (d, w.querySelectorAll (x)), d} catch (y) {} finally {r || b.removeAttribute ("id")}}} return i (a.replace (R, "$ 1" ), gb b, d, e)} function () {var a = []; la función b (c, e) {return a.push (c + "")> d.cacheLength && eliminar b [a.shift ()], b [c + ""] = e} return b} function hb (a) {return un [u] = 0, a} ib función (a) {var jb (a, b) {var c = a.split ("|"), e = a.length, mientras que (e -) d.attrHandle [c [e]] = b} function kb (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex || D) - (~ a.sourceIndex || D), si (d) la devolución d; si ( c) mientras (c = c.nextSibling) si (c === b) devuelven-1; devolver un 1: -1} function libras (a) {retorno de la función (b) {var c = b.nodeName.toLowerCase (); return "entrada" === c && b.type === A}} function mb (a) {retorno de la función (b) {var c = b.nodeName.toLowerCase (); return ("entrada" === "botón" c || === c) && b.type === a}} nb función (a) {hb retorno (function (b) {return b = + b, hb (function (c, d) {var e, f = a ([], c.length, b), g = f.length;! while (g -) c [e = f [g]] && (c [e] = (d [e] = c [e]))})})} function ob (a) {return a && typeof a.getElementsByTagName! == C && a} c = fb.support = {}, f = fb.isXML = function (a) {var b = a && (a.ownerDocument || a) .documentElement; retorno b "HTML" == b.nodeName:?! 1}, m = fb.setDocument = function (a) {var b, e = a una!?. ownerDocument || a: v, g = e.defaultView; retorno a.className = "i",! a.getAttribute ("className")}), c.getElementsByTagName = ib (function (a) {return a.innerHTML = "<div class =" a "> </ div> <div class = 'a ! b.getElementById == C && p) {var c = b.getElementById (a); retorno c && c.parentNode [c]: []}}, d.filter.ID = function (a) {var b = a.replace (cb, db); función de retorno (a) {return a.getAttribute ("id") === b}}) :( eliminar d.find.ID, d.filter.ID = function (a) {var b = a.replace (cb, db); función de retorno (a) {var c = typeof a.getAttributeNode == C && a.getAttributeNode ("id");! devolver c && c.value === b}}), d.find .tag = c.getElementsByTagName función (a, b) {return typeof b.getElementsByTagName == b.getElementsByTagName C (a):? void 0}: la función (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a), si ("*" === a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); retorno d} return f}, d.find.CLASS = function c.getElementsByClassName && (a, b) {return typeof b.getElementsByClassName == C && p b.getElementsByClassName (a):? void 0}, r = [], q = [], ( c.qsa = $. de prueba (e.querySelectorAll)) && (ib (function (a) {a.innerHTML = "<seleccionar msallowclip = ''> <option RegExp (q.join ("|")), r = r.length && nueva RegExp (r.join ("|"))., B = $ test (o.compareDocumentPosition), t = b || $ .test (o ?? .contains) función (a, b) {var c = 9 === a.nodeType a.documentElement: a, d = b && b.parentNode; retorno l = 0,0;!!! var d = a.compareDocumentPosition- b.compareDocumentPosition; retorno l = 0,0;! var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], i = [b]; if (!! f || g) volver a = ??? == e -1: b === e 1: f -1: g 1: k K.call (k, a) -K.call (k, b):? 0; si (f = == g) la devolución ? d kb (h [d], i [d]): h [d] === v -1:? i [d] === v 1:? 0}, e): n}, fb.matches = function (a, b) {return d = s.call (a, b); if (! d || || c.disconnectedMatch a.document && 11 == a.document.nodeType) retorno d} catch (e) {} return e = d.attrHandle [b.toLowerCase ()], f = e && E.call (d.attrHandle, b.toLowerCase ()) e (a, b, p!): void 0; retorno vacío nuevo error ("Error de sintaxis, la expresión no reconocido:" + a)}, fb.uniqueSort = function (a) {var k = null, a}, e = fb.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; si (f) {if (1 === f || 9 === f || 11 === f) {if ("cadena" == typeof a.textContent) volver a.textContent; para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) volver a.nodeValue} else while (b = a [d ++]) c + = e (b); retorno a [1] = a [1] .replace (cb, db), un [3] = (a [3] || un [4] || un [5] || ""). reemplazar (cb, db ), "~ =" === a [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)}, NIÑO: function (a) {return b, c = a [6] && un [2];! devolución b = a.replace (cb, db) .tolowercase (); return "*" === una función () {return 0!}: function (a) {return a.nodeName && a.nodeName.toLowerCase () ==? = b}}, CLASE: function (a) {var b = y [a + ""]; retorno b || (b = new RegExp ("(^ |" + M + ")" + a + "(" + M + " | $) ")) && y (a, función (a) {return b.test (" cadena "! == typeof a.className && a.className || typeof a.getAttribute == C && a.getAttribute (" clase ") || "")})}, ATTR: function (a, b, c) {retorno de la función (d) {var e = fb.attr (d, a); retorno "+ E +" ! f = "enésima" == a.slice (0,3), g = "último" == a.slice (-4), h = "de tipo" === b;! devolver 1 === ? d && 0 === e función (a) {return !! a.parentNode}: function (b, c, i) {var si (s && (j = (b [u] || (b [u] = {})) [a]) && j [0] === w) m = j [1]; lo demás m- = e, m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || fb.error ("pseudo sin apoyo:" + a);?? vuelta de correo [u] e (b): e.length> 1 (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ()) hb (función (a, c) {var d, f = e (a, b), g = f.length;? while (g- -) d = K.call (a, f [g]), un [d] = (c [d] = f [g])}): function (a) {return e (a, 0, c)! }): e}}, pseudos: {no: hb (function (a) {var b = [], c = [], d = h (a.replace (R, "$ 1")); retorno d u [ ?] hb (función (a, b, c, e) {var f, g = d (a, null, e, []), h = a.length; while (h -) (f = g [h ]) && (a [h] = (b [h] = f!))}): function (a, e, f) {return b [0] = a, d (b, null, f, c), ! c.pop ()}}), cuenta con: hb (function (a) {retorno de la función (b) {fb retorno (a, b) .length> 0}}), contiene: hb (function (a) {return función (b) {. retorno (b.textContent || b.innerText || e (b)) indexOf (a)> - 1}}), lang: HB (function (a) {return W.test (a | ? | "") || fb.error ("sin soporte lang:" + a), a = a.replace (cb, db) .tolowercase (), función (b) {var c; hacer si (c = p b .lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang")) return c = a.location && a.location.hash; regresar c && c.slice (1) === b.id}, raíz: function (a) {return una o ===}, enfoque: función (a) {return ! a.disabled === 1}, discapacitados: function (a) {return a.disabled === 0}, comprobado: la función (a) {var Z.test (a.nodeName)}, entrada: function (a) {return Y.test (a.nodeName)}, un botón: function (a) {var b = a.nodeName.toLowerCase (); return "de entrada" === b && "botón" === a.type || "botón" === b}, texto: function (a) {var c = 0; b> c; c + = 2) a.push (c); volver a}), impar: nb (función (a, b) {for (var c = 1; b> c; c + = 2) a.push (c); volver a}), LT: nb (función (a, b, c) {for (var d = 0> c c + b:? c; - d> = 0;) a. push (d); volver a}), gt: nb (function (a, b, c) {for (var d = 0> c c + b: c; ++ d <b;) a.push (d ); volver a})}}, d.pseudos.nth = d.pseudos.eq; para (b {en la radio:!!!!! 0, casilla: 0, archivo: 0, contraseña: 0, imagen: 0 }) d.pseudos [b] = libras (b), por (b {en presentar: 0, reset: 0}) d.pseudos [b] = mb (b); la función PB () {} pb. prototipo = d.filters = d.pseudos, d.setFilters = new pb, g = fb.tokenize = function (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; si (k) de retorno ")}), H = h.slice (c.length)); for (g en ? b h.length: h fb.error (a): z (a, i) .slice (0)}; función qb (a) {for (var b = 0, c = a.length, d = " "; c> b; b ++) d + = a [b] .value; retorno d} rb función (a, b, c) {var d = b.dir, e = c &&" parentNode "=== d, f = x ++; volver b.first función (b, c, f) {while (b = b [d]) si (1 === b.nodeType || e) volver a (b, c, f)}: función? (b, c, g) {var h, i, j = [w, f]; si (g) {while (b = b [d]) if ((1 === b.nodeType || e) && un (b, c, g)) return 0} else while (b = b [d]) si (1 === b.nodeType || e) {if (i = b [u] || (b [u ] = {}), (h = i [d]) && h [0] === w && h [1] === f) la devolución j [2] = h [2]; si (i [d] = j, !? j [2] = a (b, c, g)) return 0}}} function sb (a) {a.length retorno> 1 función (b, c, d) {var e = a.length; mientras (e -) return 1; return 0}: a [0]} function tb (a, b, c) {for (var d = 0 (a [e] (b, c, d)!)! , e = b.length; e> d; d ++) fb (a, b [d], c); retorno c} ub función (a, b, c, d, e) {for (var f, g = [ !], h = 0, i = a.length, j = null = b; i> h; h ++) (! f = a [h]) && (c || c (f, d, e)) && ( g.push (f), j && b.push (h)); retorno g} vb función (! a, b, c, d, e, f) {return d && d [u] && (d = vb (d)) , e &&! e [u] && (e = vb (e, f)), hb (function (f, g, h, i) {var r = ub (r === g r.splice (o, r.length):? r), correo electrónico (null, g, r, i):? I.apply (g, r)})} function wb (a) {for (var b, c, e, f = a.length, g = d.relative [a [0] .type], h = g || d.relative [""], i = g? 1: 0, k = rb (! función (a) {return una === b}, h, 0), l = rb (function (a) {return vb (i> 1 && sb (m), i> 1 && qb (a.slice (0, i-1) .concat ({valor: " sb (m)} function xb (a, b) {var c = b.length> 0, e = a.length> 0, f = function (f, g, h, i, k) {var k && (w = v, j = t), r}; retorno c hb (f): f} return h = fb.compile = function (a, b) {var c, d = [], e = []? , f = A [a + " f}, i = fb.select = function (a, b, e, f) {var i, j, k, l, m, n = "función" == typeof 1 & a.compareDocumentPosition (n.createElement ("div"))}), ib (function (a) {return a.innerHTML = "<a ? c vacío 0: a.getAttribute (b, "tipo" === b.toLowerCase () 1: 2)}), c.attributes && ib (function (a) {return c || "entrada" == a.nodeName.toLowerCase () void 0:!? a.defaultValue}), ib (function (a) {return null == a.getAttribute ("disabled")}) || jb (L, la función (a, b, c) {var d; c retorno vacío? u = n.expr.match.needsContext, v = / ^ <? (\ w +) \ s * \ /> (:? <\ / \ 1> |) $ /, w = / ^ [^:. # \ [\,.] * $ /; función x (a, b, c) {if (n.isFunction (b)) n.grep retorno (a, función (a, d) {return !! b.call (una , d, a) == c}); if (! b.nodeType) n.grep retorno (a, función (a) {return una === b == c}); if (! "cadena" == typeof b) {if (w.test (b)) n.filter retorno (b, a, c); b = n.filter (b, a)} n.grep retorno (a, función (a) {return g .call (b, a)> = 0 == c})} n.filter = function (a, b, c) {var d = b [0];! devolución 1 === a.nodeType}))}, n.fn.extend ({encontrar: function (a) {var b, c = this.length, d = [], e = esto; si ("cadena"! = typeof a) la devolución d = this.pushStack (c> 1 n.unique (d): d), d.selector = this.selector this.selector + "" + a:? a, d}, Filtro: function (a) {return este .pushStack (x (esto, a || [] ,! 1))}, no: función (a) {return this.pushStack (x (esto, a || [] ,! 0))}, es: función (a) {return !! x (esto, "string" == typeof a && u.test (a) n (a):? a || [] ,! 1) .length}}); var y, z = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, A = n.fn.init = function (a, b ) {var c, d; if (a) regrese esta; si ("cadena" == typeof instanceof en b) n.isFunction (esto [c]) este [c] (b [c]):? this.attr (c, b [c]); devuelva esta} return a.nodeType (this.context = esta [0] = a, this.length = 1, este):?! n.isFunction (a) "indefinido" = typeof y.ready y.ready (a): un (n) :( void d = [], e = 0 void == c;! while (! (a = a [b]) && 9 == a.nodeType) si (1 === a.nodeType) {if (e && n (a). es (c)) romper; d.push (a)} return d}, hermano: function (a, b) {for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && un ! == b && c.push (a); retorno c}}), n.fn.extend ({tiene: function (a) {var b = n (a, este), c = b.length; volver this.filter (function () {for (var a = 0; c> a; a ++) si (n.contains (este, b [a])) devuelve 0!})}, más cercano: la función (a, b) {for ( var c, d = 0, e = this.length, f = [], g = u.test (a) || "cadena"! = typeof this.pushStack (f.length> 1 n.unique (f): f)}, índice: function (a) {return una "cadena" == typeof? this.pushStack (n.unique (n.merge (this.get (), n (a, b))))}, addBack: function (a) {return this.add (null == un this.prevObject?: ! this.prevObject.filter (a))}}); la función D (a, b) {while ((a = a [b]) && 1 == a.nodeType); volver a} n.each ({padre: función (a) {!? var = b a.parentNode; retorno b && 11 == b.nodeType b: null}, los padres: función (a) {n.dir retorno (un "parentNode",)}, parentsUntil: function ( a, b, c) {n.dir retorno (a, "parentNode", c)}, siguiente: function (a) {return D (a, "nextSibling")}, prev: function (a) {return D ( a, "PreviousSibling")}, SiguienteAll: function (a) {n.dir retorno (a, "nextSibling")}, prevAll: function (a) {return n.dir (a, "previousSibling")}, nextUntil: function ( a, b, c) {return n.dir (a, "nextSibling", c)}, prevUntil: function (a, b, c) {n.dir retorno (a, "previousSibling", c)}, hermanos: función (a) {return n.sibling ((a.parentNode || {}) firstChild, a.)}, los niños: la función (a) {return n.sibling (a.firstChild)}, contenidos: function (a) {return a.contentDocument || n.merge ([], a.childNodes)}}, la función (a, b) {n.fn [a] = función (c, d) {var e = n.map (esto , b, c);! retorno "Hasta" == a.slice (-5) && (d = c), d && "cadena" == typeof E = / \ S + / g, F = {}; función G (a) {var b = F [a] = {}; n.each retorno (a.match (E) || [], la función (a, c) {b [c] = 0!}), b} n.Callbacks = function (a) {a = "cadena" == typeof un F [a] || G (a):? n.extend ({ }, a); var c = h.length;! función g (b) {n.each (b, la función (b, c) {var esto}, remover: function () {return h && n.each (argumentos, la función (a, b) {var ? un n.inArray (a, h)> - 1: (! h || h.length)}, vacío: function () {return h = [], f = 0, esto}, desactivar: function ( ) {return h = i = b = 0 vacío, esto}, discapacitados: function () {! devolver h}, cerradura: function () {return i = vacío k.fireWith (este, argumentos), esto}, disparó: function () {return !! c}}; retorno k}, n.extend ({Diferido: function (a) {var b = [["determinación", "hecho", n.Callbacks ("una vez que la memoria"), "resuelva"], ["rechazar", "fail", n.Callbacks ("una vez c}, siempre: function () {return e.done (argumentos) .fail (argumentos), esto}, a continuación: function () {var a = argumentos; regresan n.Deferred (function (c) {n.each ( b, la función (b, f) {var g = n.isFunction (a [b]) && un [b]; e [f [1]] (function () {var null = un n.extend (a, d): d}}, e = {}; volver d.pipe = d.then, n.each (b, la función (a, f) {var!? Array (e), j = new Array (e), k = new f || g.resolveWith (k, c), g.promise ()}}); var H; n.fn.ready = función (a) {return J = n.access = function (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; si ("objeto" === n .type (c)) {e = 0;! a (h en c) n.access (a, b, h, c [h] ,! 0, f, g)}! else if (vacío 0 == d && (e = 0, n.isFunction (d) || (g = 0), j && (g? (b.call (a, d), b = null) :( j = b, b = función (una , b, c) {return j.call (n (a), c)})), b)) para (; i> h; h ++) b (a [h], c, g d:? d.call (a [h], h, b (a [h], c))); regresan e a: j b.call (a): i b (a [0], c):??? f}; n .acceptData = function (a) {return 1 === a.nodeType || 9 === a.nodeType || + a.nodeType!}; función 0; var this.cache [c] || (this.cache [c] = {}), c}, sistema: la función (a, b, c) {var d, e = this.key (a), f = esto. caché [e]; si ("cadena" == b typeof) f [b] = c; else if (n.isEmptyObject (f)) n.extend (this.cache [e], b); otra para (d en b) f [d] = b [d]; retorno f}, obtener: function (a, b) {var c = this.cache [this.key (a)]; vuelve vacía 0 === b c? : c [b]}, acceso: function (a, b, c) {var d; vuelve vacía 0 === b || b && "cadena" == typeof b && vacío 0 === c (d = this.get? (a, b), nula 0 == d d:!?!? this.get (a, n.camelCase (b))) :( this.set (a, b, c), nula 0 == c c : b)}, remover: function (a, b) {var c, d, e, f = this.key (a), g = this.cache [f]; si (void 0 === b) esto. caché [f] = {};?? else {n.isArray (b) d = b.concat (b.map (n.camelCase)) :( e = n.camelCase (b), b en g d = [ ? b, e] :( d = e, d = d en g [d]: d.match (E) || [])), c = D.Length; while (c -) eliminar this.cache [a [this.expando]]}}; var L = new K, M = new K, N = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, O = / ([AZ]) / g; función P (a, b, c) {var d; si (void c = 0 vacío; retorno c} n.extend ({HasData: function (a) {return M.hasData (a) || L.hasData (a)}, los datos: function (a, b, c) {return M .Acceso (a, b, c)}, REMOVEDATA: function (a, b) M.remove {(a, b)
}, _ Datos: function (a, b, c) {return L.access (a, b, c)}, _ REMOVEDATA: function (a, b) L.remove {(a, b)}}), n.fn .extend ({datos: function (a, b) {var c, d, e, f = esta [0], g = f && f.attributes; si (void e} return "objeto" == typeof un this.each (function () {M.set (esto, a)}):? J (esto, la función (b) {var c, d = n.camelCase (a) ; si (f && vacío 0 === b) {if (c = M.get (f, a), nula 0 == c!) return c; si (c = M.get (f, d), nula 0! == c) retorno c; if (! c = P (f, d, nula 0), nula 0 == c) retorno c} else this.each (function () {var c = M.get (esto, d ); M.set(Esto, d, b), - 1 == a.indexOf ("-")! && Vacío 0 == c && M.set (esto, a, b)})}, null, b, arguments.length> 1, null, 0)}, REMOVEDATA: función (a) {return this.each (function () {M.remove (esto, a)})}}), n.extend ({cola: la función (a, b, c) {var d; retorno 0}, quitar de la cola: function (a, b) {b = b || "fx"; var f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; volver L.get (a, c) || ??L.access (a, c, {vacías: n.Callbacks ("una vez que la memoria"). add (function () {L.remove (a, [b + "cola", c])})}) }}), n.fn.extend ({cola: function (a, b) {var c = 2; volver "cadena" = typeof a && (b = a, a = "fx", c -), argumentos! .length <c n.queue (esto [0], a): void 0 === b esto:? this.each (function () {var this.each (function () {n.dequeue (esto, a)})}, clearQueue: function (a) {return this.queue (un "fx" || [])}, promesa: la función (a, b) {var c, d = 1, e = n.Deferred (), f = este, g = this.length, h = function () {- d || e.resolveWith (f, [f])} ; "cadena" = typeof a && (b = a, a = vacío 0), a = a || "fx";! while (g -) c = L.get (f [g], A + "queueHooks") , c && c.empty && (d ++, c.empty.add (h)); retorno h (), e.promise (b)}}); var U = "undefined"; k.focusinBubbles = "onfocusin" en una; var Z () {! Devolver 0} function $ () {! Volver 1} function _ () {try {return l.activeElement} catch (a) {}} = {n.event mundial: {}, añadir: function ( a, b, c, d, e) {var typeof n == U && n.event.triggered == b.type n.event.dispatch.apply (a, argumentos):!? vacío i [o])} else para (o en i) n.event.remove (a, o + b [j], c, d, 0);! n.isEmptyObject (i) && (borrar r.handle, L .Extraer (a, "eventos"))}}, disparador: function (b, c, d, e) {var n.Event (q, "objeto" == typeof b && b), b.isTrigger = e 2: 3, b.namespace = r.join ("."), b.namespace_re = b.namespace nueva RegExp ("? (^ | \\). "+ r.join (" \\ (:.?.. * \\ |) ") +" (. \\ | $) "): null, b.result = vacío 0, h && (d [k] = h)), b.result}}, de expedición: function (a) {a = n.event.fix (a); var 0! == E && (a.result = e) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (esto, a), a.result} }, manipuladores: función (a, b) {var ", Anular h <b.length && g.push ({elem: esto, los manipuladores: b.slice (h)}), g}, props: "altKey burbujas cancelable vista TimeStamp objetivo ctrlKey currentTarget eventPhase metakey relatedTarget shiftKey que" .split ("") , fixHooks: {}, keyHooks: {props: "charCode carbón keyCode tecla" .split (""), Filtro: function (a, b) {return null == a.which && (a.which = null = b!. ? charCode b.charCode: b.keyCode), un}}, mouseHooks: {props: "buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement" .split (""), el filtro: function (a, b) {var c, d, e, f = b.button; retorno 0 === f || (??? A.which = 1 & f 1: 2 & f 3: 4 & f 2: 0), a}}, fijar: function (a) {if (a [n.expando]) devuelve una; var n.Event (f), b = D.Length, mientras que (b -) c = d [b], a [c] = f [c]; retorno esta == _ () && this.focus (this.focus () ,! 1):? void 0}, delegateType: "focusin"}, falta de definición: {gatillo: function () {return este === _ () && this.blur (this.blur () ,! 1): void 0}, _ default: function (a) {return n.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function (a) {void e = n.extend (nuevo este instanceof f, g; if (! "objeto" == typeof a) {"cadena" = typeof b && (c = c || b, b = vacío 0); for (g en a) this.on (g, b, (? nula == c && nula == d (d = b, c = b = 0 nula); c, a [g], e) devolver este} if: null == d && ("cadena" == typeof b (? d = c, c = vacío 0) :( d = c, c = b, b = vacío 0)), d === 1) d = $;! else if (d) devolver este; volver 1 == = e && (f = d, d = function (a) {return this.on (a, b, c, d, 1)}, off: la función (a, b, c) {var d, e; si (a && && a.preventDefault a.handleObj) retorno a) {for (e en a) this.off (e, b, a [e]); devolver este} return (b === 1 || "función" == typeof b) && (c = b,! b = 0 void), c === 1 && (c = $), this.each (function () {n.event.remove (esto, a, c, b)})}, disparador: la función (a, b) {return this.each (function () {n.event.trigger (a, b, este)})}, triggerHandler: function (a, b) {var c = esta [0]; retorno c n?. event.trigger (a, b, c, 0!): void 0}}); var jb (a, b) {return kb (a) {return a.type = (null! == a.getAttribute ("tipo")) + "/" + a.type, un} function libras (a) {var b = gb.exec (a. ? Tipo); b retorno a.type = b [1]: a.removeAttribute ("tipo"), un} mb de función (a, b) {for (var c = 0, d = a.length; d> c ; c ++) L.set (! un [c], "globalEval", b || L.get (b [c], "globalEval"))} function nb (a, b) {var c, d, e, f, g, h, i, j; si (1 === b.nodeType) {if (L.hasData (a) && (f = L.access (a), g = L.set (b, f) , j = f.events)) {delete g.handle, g.events = {}; para (e en ob (a, b) {var void 0 === b || b && n.nodeName (a, b) n.merge ([a], c):? c} function pb (a, b) {var nb (a, h); retorno g = ob (h, "guión"), g.length> 0 && mb (! g, i && ob (un "guión",)), h}, buildFragment: function (a, b, c , d) {for (var k}, CleanData: function (a) {for (var b, c, d, e, f = n.event.special, g = 0; void 0 == (c = a [g]); g ++!) { si (n.acceptData (c) && (e = c [L.expando], e && (b = L.cache [e]))) {if (b.events) para (d en b.events) f [d ] n.event.remove (c, d):? n.removeEvent (c, d, b.handle); L.cache [e] && eliminar L.cache [e]} borrar M.cache [c [M.expando ]]}}}), n.fn.extend ({texto: function (a) {return J (esto, la función (a) {void retorno this.domManip (argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = jb (esto, a); b.appendChild (a)}})}, anteponga: function () {return this.domManip (argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = jb (esto, a); b.insertBefore (a, b.firstChild)}})}, antes: function () {return esto}, vacío: function () {for (! var a, b = 0; null = (a = esta [b]); b ++) 1 === a.nodeType && (n.cleanData (ob (a, 1 )), a.textContent = "");} devuelva este, clon: function (a, b) {return una = null == 1: a, b = == null b a: b, esto?!?. mapa (function () {n.clone de retorno (esto, a, b)})}, html: function (a) {return J (esto, la función (a) {var b = esta [0] || {}, c = 0, d = this.length; si (void 0 === a && 1 === b.nodeType) volver b.innerHTML; si ("cadena" == typeof a = argumentos [0]; retorno this.remove (a, 0!)}, domManip: function (a, b) {a = e.apply ([], a); var c, d, f, g, h, i, j = 0, l = this.length, m = este, o = l-1, p = a [0], q = n.isFunction (p), si (q || l> 1 && "cadena" == typeof p && && k.checkClone eb! .test (p)) volver this.each (function (c) {var this.pushStack (d)}}); qb var, rb = {}; función sb (b, c) {var e.detach (), f} function tb (a) {var b = l, c = rb [a]; retorno c || (c = sb (a, b), "ninguno" == c && c || (! qb = (qb || n ("<'0' iframe width = frameborder =" 0 " ub = / ^ margen /, vb = new RegExp ("^ (" + Q + ") (?! px) [az%] + $", "i"), wb = function (a) {return a.ownerDocument. defaultView.getComputedStyle (a, null)}; xb función (a, b, c) {var d, e, f, g, h = a.style; regreso !? 0 == g g + "": g} yb función (a, b) {return {get: function () {return a () void borrar this.get:? (This.get = b) .apply (este , argumentos)}}}! function () {var g (), b}, boxSizingReliable: function () {return null == c && g (), c}, reliableMarginRight: function () {var b, c = f.appendChild (l.createElement ("div")); retorno e, f, g = {}; para (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []); para. (f en b) a.style [f] = g [f]; retorno e};?! var zb = / ^ (ninguno | Mesa (- c [ea]) +) /, Ab = new RegExp ("^ (" + "$) (. *)" Q +, "i"), Bb = new Fb (a, b) {if (b en a) la devolución b; var c = b [0] .toUpperCase () + b.slice (1), d = b, e = Eb.length; mientras (E-- ) si (b = Eb [e] + c, b, a) la devolución b; retorno d} function Gb (a, b, c) {var d = Ab.exec (b); retorno d Math.max (0 , d [1] - (c || 0)) + (d [2] || "px"): b} function Hb (a, b, c, d, e) {for (var g función} Ib (a, b, c) {var e; d = g && (k.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} return e + Hb (a, b, c || (g? , d, f) +} function "px" Jb (a, b) {for (var "contenido"): "frontera" a} n.extend ({cssHooks: {opacidad: {get: function (a, b) {if (b) {var e, f, g, h = n.camelCase (b), i = a.style; retorno b = n.cssProps [h] || (n.cssProps [h] = Fb (i, h)), g = n.cssHooks [b] || n.cssHooks [h], nula 0 === c g && "obtener" en g && vacío 0 == (e = g.get (a, 1, d)!) e?!?: i [b] :( f = typeof g && void 0 === (c = g.set (a, c, d)) || (i [b] = c)), void 0)}}, css: function (a, b, c, d) { var e, f, g, h = n.camelCase (b); retorno b = n.cssProps [h] || (n.cssProps [h] = Fb (a.style, h)), g = n.cssHooks [b] || n.cssHooks [h], g && "obtener" en g && (e = g.get (a, 0, c)), void 0 === e && (e = xb (a, b, d )), === e && b "normal" en ? c zb.test (n.css (un "display")) && 0 === a.offsetWidth n.swap (a, Cb, función () {return Ib (a, b, d)}): Ib (a, b, d): void 0}, establezca: function (a, c, d) {var e = d && wb (a); retorno b n.swap (a, {display: "inline-block"}, xb, [a, "marginRight"]): void d = 0, e = {}, f = "cadena" == typeof c c.split (""):? [c]; 4> d; d ++) e [a + R [d] + b] = f [d] || f [d-2] || f [0]; volver e}}, ub.test (a) || (n.cssHooks [a + b] .set = Gb)}), n. fn.extend ({css: function (a, b) {return J (esto, la función (a, b, c) {var d, e, f = {}, g = 0; si (n.isArray (b) ) {for (d = wb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); retorno f } return vacío 0 == c n.style (a, b, c):? n.css (a, b)}, a, b, arguments.length> 1)}, espectáculo: function () {return Jb (esto, 0!)}, ocultar: function () {return Jb (este)}, alternar: function (a) {return "booleano" == typeof a a this.show ():?? this.hide () : this.each (function () {S (esto) n (esto) .Show ():? n (esto) .Hide ()})}}); función Kb (a, b, c, d, e) {return nuevo a = Kb.propHooks [this.prop]; volver a && a.get a.get (este):? Kb.propHooks._default.get (este)}, ejecute: function (a) {var b, c = Kb.propHooks [this.prop]; retorno b; retorno a}, columpio: function (a) {return.5-Math.cos (a * Math.PI) / 2}}, n.fx = Kb.prototype.init, n.fx.step = {}; var Lb , Mb, Nb = / ^ (?: basculante | mostrar | ocultar) $ /, Ob = new RegExp ("^ (: ([+ -]) = |) (?" + Q + ") ([az] *% ) $ "," i "), Pb = / queueHooks $ /, Qb = [Vb], Rb = {" "*: [función (a, b) {var h = h || "0.5", g / = h, n.style (c.elem, a, g + f);! while (h == (h = c.cur () / d) && 1 = = h && - i)} return e && (? g = c.start = + g + d || || 0, c.unit = f, c.end = e [1] g + (e [1] 1) * e [2]: + e [2]), c}]}; función Sb () {return setTimeout (function () {Lb = vacío}),)} function (0 Lb = n.now Tb (a, b) {var c, d = 0, e = {height: a}; para (b = b 1: 0; 4> d; d + = 2-b) c = R [d], e ["margen" + c] = e ["relleno" + c] = a; b retorno && (e.opacity = e.width = a), e} function Ub (a, b, c) {for (var d, e = (Rb [b] || []) concat (Rb ["*"]), f = 0, g = e.length;. g> f; f ++) si (d = e [f] .call (c, b, a)) return d} Vb función (a, b, c) {var b || "ancho" en en b) si (e = b [d], Nb.exec (e)) {if (borrar b [d], f = f || "palanca" === e, e === (p? "ocultar ":" show ")) {if (" show "== e || q || vacío 0 === q [d]) continuar; p = 0!!!} m [d] = q && q [d] || n.style (a, d)} else j = 0 vacío;? si (n.isEmptyObject (m)) "en línea" === ("ninguno" === tb j (a.nodeName ): j) && (o.display = j); else {q "escondido" en? b; L.remove (a, "fxshow"); for (b en m) n.style (a, b, m [b])}); for (d en m) g = Ub (q p [d ]: 0, d, l), d en q || (q [d] = g.start, (g.end = g.start, g.start = "width" && p === d || "altura" ? === d 1: 0))}} function Wb (a, b) {var c, d, e, f, g, porque (c en a) si (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, eliminar un [c]), g = n.cssHooks [d], g && "ampliar" en g) {f = g.expand (f), eliminar un [d]; para (c en f) c en a || (a [c] = f [c], b [c] = e)} else b [d] = e} function Xb (a, b, c) {var d, e, f = 0, g . = Qb.length, h = n.Deferred () siempre (function () {delete i.elem}), i = function () {if (e) return 1;! for (var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); j.tweens.push retorno (d), d}, parada: function ( b) {var c = 0, d = b j.tweens.length: 0; si (e) volver esto, porque (e = 0, d> c, c ++) j.tweens [c] .run (1 ); retorno d; retorno "); For (var d = un "objeto" && == typeof d.duration = n.fx.off 0:?? "número" == d.duration typeof d.duration: d.duration en e = n.isEmptyObject (a), f = n.speed (b, c, d), g = function () {var b = Xb (esto, n.extend ({}, a), f); (e || L.get (esto "acabado")) && b.stop (0)}; volver g.finish = g, e || f.queue === 1 this.each (g): esto!?. cola (f.queue, g)}, parada: la función (a, b, c) {var d = function (a) {var b = a.stop; eliminar a.stop, b (c)}; volver "cadena "! = typeof a && (c = b, b = a, a = vacío 0), b && a! ==! 1 && this.queue (a ||" fx ", []), this.each (function () {var b !! = 0, e = null = a && A + "queueHooks", f = n.timers, g = L.get (este), si (e) g [e] && g [e] .Stop && d (g [e]); otra cosa para (e en a! ==! 1 && (a = a || "fx"), this.each (function () {var c.finish})}}), n.each (["cambiar", "show", "ocultar"], la función (a, b) {var c = n.fn [b]; n.fn [b] = function (a, d, e) {return null == a || "booleano" == typeof this.animate (b, a, c, d)}}), n.timers = [], n.fx.tick = function () {var a = n.fx n.fx.speeds [a] || a:? a, b = b || "fx", this.queue (b, la función (b, c) {var d = setTimeout (b, a ); c.stop = function () {clearTimeout (d)}})}, function () {var Yb, Zb, $ b = n.expr.attrHandle; n.fn.extend ({attr: function (a, b) {return J (esto, n.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {n.removeAttr (esto, a)})}}), n.extend ({attr: function (a, b, c) {var d, e , f = a.nodeType; if (!!! a && 3 == f && 8 == f && 2 == f) la devolución typeof 0 === c d && "obtener" en d && nula == (e = d.get (a, b)) e:?!?? (E = n.find.attr (a, b), == null e vacío 0: e): nula == c d && "set" en d && vacío 0 == (e = D.SET (a, c, b)) e:?!? (a.setAttribute (b, c + ""), c): void n.removeAttr (a, b))
}, RemoveAttr: function (a, b) {var c = a.value; volver a.setAttribute ("tipo", b), c && (a.value = c), b}}}}}), Zb = {conjunto: function (a, b, c) {return c = $ b [b] || n.find.attr; $ b [b] = function (a, b, d) {var e, f; retorno d || (f = $ b [b], $ b [b] = e, e = null = c (a, b, d) b.toLowerCase ():!? null, $ b [b] = f), e}}); _b var = / ^ (?: Entrada | Seleccionar | textarea botón |) $ / i; n.fn.extend ({prop: function (a, b) {return J (esto, n.prop, a, b, arguments.length> 1)}, removeProp : function (a) {return this.each (function () {borrar d, e, f, g = a.nodeType;! if (!!!! a && 3 == g && 8 == g && 2 == g) return f = 1 == g || n.isXMLDoc (a), f && (b = n.propFix [b] || b, e = n.propHooks [b]), nula 0! == c? e && "set" en e && vacío 0! == (d = e.set (a, c, b) ) d:? A [B] = c: e && "obtener" en e && nula == (d = e.get (a, b)) d:? A [B]}, propHooks: {tabIndex: {get: función (a) {return b = a.parentNode; retorno ac = / [\ t \ r \ n \ f] /g;n.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h = "cadena" == typeof a && a, i = 0, j = this.length; si (n.isFunction (a)) return "+ C.className +" ") .replace (ac", "):" ")) {f = 0, mientras que (e = b [f ++]) d.indexOf (" "+ e +" ") <0 && (d + = e + ""); g = n.trim (d), c.className == g && (c.className = g)}} devolver este, removeClass: función (a) {var b, c, d, e, f, g, h = 0 === arguments.length || "cadena" == typeof a && a, i = 0, j = this.length; si (n.isFunction (a)) return "+ C.className +" ") .replace (ac", "):" ")) {f = 0, mientras que (e = b [f ++]), mientras que (d.indexOf (" "+ e +" ")> = 0) d = d.replace ("" + e + "", ""); g = a n.trim (d): "!", c.className == g && (c.className = g)} devuelve este }, toggleClass: function (a, b) {var c = typeof a; "booleano" retorno == typeof b = "" + a + "", c = 0, d = this.length; d> c, c ++) si (1 === esta [c] .nodeType && ("" + este [c] .className + "") .replace (ac, "") .indexOf (b)> = 0) return 0; volver 1}}); var bc = / \ r / g; n.fn.extend ({val:!! función (a) {var b, c, d, e = esta [0]; {if (arguments.length) retorno d = n.isFunction (a), this.each (function (c) {var e; 1 === esto. nodeType && (e = d a.call (esto, c, n (esto) .val ()):? e = a, == null e "": "? número"? == typeof e + e = "": n .isArray (e) && (e = n.map (e, la función (a) {return null == un "?": a + ""})), b = n.valHooks [this.type] || n. valHooks [this.nodeName.toLowerCase ()], b && "set" en b && vacío 0 == b.set (este, e, "valor") || (this.value = e))}); if (e) volver b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "obtener" en b && vacío 0! == (c = b.get (e, "valor")) ? c: (c = e.value, "cadena" == typeof c c.replace (bc, "?"): null == c? "": c)}}}), n.extend ({valHooks: {opción: {get:!? función (a) {var b = n.find.attr (un "valor",); return null = b b: n.trim (n.text (a))}}, seleccione : {get: function (a) {for (var b; g.push (b)} return g}, establezca: function (a, b) {var n.isArray (b) a.checked = n.inArray (n (a) .val (), b)> = 0:? void 0}}, k.checkOn || (n.valHooks [esto] .get = función (a) {return null === a.getAttribute ("valor") "en":? a.value})}), n.each ("enfoque desenfoque focusin carga focusOut desplazamiento de cambio de tamaño de descarga, haga clic dblclick mousedown mouseup mousemove mouseover mouseout cambio MouseEnter mouseleave seleccionar presentar keydown keyup pulsación error contextual ".split (" "), la función (a, b) {n.fn [b] = function (a, c) {arguments.length retorno> 0? this.on (b, nulo, a, c): this.trigger (b)}}), n.fn.extend ({emergente: la función (a, b) {return this.mouseenter (a) .mouseleave (b || un )}, se unen: la función (a, b, c) {return this.on (a, nula, b, c)}, desenlaza: function (a, b) {return this.off (a, null, b)} , delegado: function (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b, c) {return 1 === arguments.length esto? .OFF (a, "**"):? this.off (b, a || "**", c)}}); var cc = n.now (), dc = / \ /; n.parseJSON = function (a) {return JSON.parse (a + "")}, n.parseXML = function (a) {var b, c; si (a ||! "return null cadena" = typeof una!); try { c = new DOMParser, b = c.parseFromString (a, "text / xml")} catch (d) {b = vacío 0} return (! b || b.getElementsByTagName ("parsererror"). longitud) && n.error ("XML no válido:" + a)., b}; var ec, fc, gc = / # * $ /, = hc / ([? &]) _ = [^ &] * /, ic = / ^ ( . *):? [ ! rc (a) {retorno de la función (b, c) {"cadena" = typeof b && (c = b, b = "*"); var sc (a, b, c, d) {var e = {}, f = a === oc; función g (h) {var i;! declaración electrónica [h] = 0, n.each (a [h ] || [], la función (a, h) {var j = h (b, c, d);?!?! regresan "cadena" = typeof j || f || e [j] i (i = j ): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} return g (b.dataTypes [0]) || e ["*"] && g ("! * ")} function tc (a, b) {var C, D, E = n.ajaxSettings.flatOptions || {};! a (c en b) vacío 0 == b [c] && ((e [c ] a:?! d || (d = {})) [c] = b [c]); regresan d && n.extend (0, a, d), a} uc función (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; mientras ("*" === i [0]) i.shift (), nula 0 === d && (d = a. mimeType || b.getResponseHeader ("Content-Type")); si (d) de (e en h) si (h [e] && h [e] .test (d)) {i.unshift (e); descanso } if (i [0] en c) f = i [0]; else {para (e en c) {if (! i [0] || a.converters [e + "" + i [0]]) { f = e; rotura} g || (g = e) f} = f || g} return f (f == i [0] && i.unshift (f), c [f]!): void 0}? vc función (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (); Si (k [1]) por (g en si ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ,! g) para (e en j) si (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["* try {b = g (b)} catch (l) {return {estado: "parsererror", error:? g l: "Sin la conversión de" + i + "para charset = UTF-8 ", acepta: {" * ": pc, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , texto ": String", html texto ": 0," json texto ": n.parseJSON," xml texto ": n.parseXML}, flatOptions: {url: 0, el contexto: 0}}, ajaxSetup: función (a, b) {return a && (b = a, a = vacío 0), b = b || {}; var b, y si (2 === t) {if {f} = {(f!), mientras que (b = ic.exec (e)) f [b [1] .tolowercase ()] = b [2]} b = f [a.toLowerCase ()]} devolver null == b nulo:? b}, getAllResponseHeaders: function () {return 2 === t e: null}, setRequestHeader: function (a, b) {var c = a.toLowerCase (); retorno t || (a = s [c] = s [c] || a, r [a] = b), esto}, overrideMimeType: function (a) {return t || (k.mimeType = a), esto}, statuscode: function (a) {var b; si (a) si (2> t) de (b en a) q [b] = [q [b], a [ b]]; v.always demás (a [v.status]); regresan este}, abortar: function (a) {var b = a || u; retorno k.data && (k.data = n.param (k.data, k.traditional)), sc (nc, k, b, v), 2 === t) de retorno "+ Pc +"; q = 0,01 ":" "): k.accepts [" * "]); for (j en v.abort (); u = "Cancelar"; for (j w; x (-1, w)}} else x (-1, "No Transport"); función x (a, b, f, h) {var j, r, s, u, w, x = b; 2! == t && (t = 2, g && clearTimeout (g), c = void v}, getJSON: function (a, b, c) n.get {return (a, b, c, "json")}, getScript: function (a, b) {n.get retorno (a, 0 nulo, b, "guión")}}), n.each (["get", "post"], la función (a, b) {n [b] = function (a, c, d, e) {return n. isFunction (c) && (e = e || d, d = c, c = vacío this.on (b, a)}}), n._evalUrl = function (a) {return b; retorno a = este, mientras que (a.firstElementChild) a = a.firstElementChild; volver a}) append (este)), esto)}, wrapInner: function (a) {return this.each (n.isFunction (a).? función (b) {n (este) .wrapInner (a.call (este, b))}: function () {var b = n (este), c = b.contents (); c.length c.wrapAll? (a): b.append (a)})}, envoltura: function (a) {var b = n.isFunction (a); volver this.each (function (c) {n (este) .wrapAll (b? a.call (este, c): a)})}, desenvuelva: function () {return Bc (a, b, c, d) {var e; si (n.isArray (b)) n.each (b, la función (b, e) {c || xc.test (a) d (a,? e): Bc (a + "[" + ("objeto" == typeof e b:? "") + "]!", e, c, d)}); else if (c || "objeto" == n.type (b)) d (a, b); otra para (e en b) Bc (a + "[" + e + "]", b [e], c, d)} n.param = function (un , b) {var para (c en a) Bc (c, a [c], b, e); volver d.join ("&") reemplazar (wc, "+")}, n.fn.extend ({serialize:. función () {return n.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = n.prop (esto, "elementos"); devuelve un n?. MakeArray (a):. esta}) filtrar (function () {var a = this.type; retorno c = n (este) .val (); retorno new XMLHttpRequest} catch (a) {}}; var una en Dc) Dc [a] ()}), k.cors = Fc !! && "withCredentials" en Fc, k.ajax = Fc = !! Fc, n.ajaxTransport (function (a) {var b; retorno k .cors || Fc && a.crossDomain {enviar:!? función (c, d) {var e, f = a.xhr (), g ++ = Cc; si (f.open (a.type, a.url , a.async, a.username, a.password), a.xhrFields) para (e en en c) f.setRequestHeader (e, c [e]); b = function (a) {retorno de la función () {b && (borrar ? f.responseText {texto: f.responseText}: void h}}, abortar: function () {b && b ()}}: void 0}), n.ajaxSetup ({acepta: {script: "text / javascript, application / javascript, application / ECMAScript, application / x-ecmascript" }, contenidos: {script: / (?: java | ecma) script /}, convertidores: {"escritura de texto": función (a) {return n.globalEval (a), un}}}), n.ajaxPrefilter ( "guión", función (a) {void ? (? = Y | $) | Gc = [], Hc = / (=) \ \ \ /; n.ajaxSetup ({jsonp:?? "Callback", jsonpCallback: function () {var a = Gc.pop () || n.expando + "_" + cc ++;! devolver este [a] = 0, a}}), n.ajaxPrefilter ("json jsonp", función (b, c, d) {var e, f, g, h = b.jsonp == 1 && (Hc.test (b.url) "url":!? "cadena" == typeof json "] = function () {return g || n.error (e +" no era 0}), "guión"):!! Nula 0}), n.parseHTML = function (a, b, c) {if (a || "cadena" = typeof a) return null; "booleano" == typeof b && (! c = b, b = 1), b = b || l; var d = v.exec (a), e = c && [];! devolución Ic = n.fn.load; n.fn.load = function (a, b, c) {if ("cadena" = typeof a && Ic!) Volver Ic.apply (esto, argumentos); var d, e, f, g = este, h = a.indexOf (""); retorno h> = 0 && (d = n.trim (a.slice (h)), a = a.slice (0, h)), n.isFunction ( ? b) (c = b, b = vacío 0): b && "objeto" == typeof n.grep (n.timers, función (b) {devuelven un b.elem ===}) longitud};. var Jc = a.document.documentElement; función Kc (a) {return n.isWindow (a)? una: 9 === a.nodeType && a.defaultView} n.offset = {setOffset: function (a, b, c) {var ? b b.using.call (a, m): l.css (m)}}, n.fn.extend ({offset: función (a) {if (arguments.length) retorno vacío 0 === una? esto: this.each (function (b) {n.offset.setOffset (esto, a, b)}); var b, c, d = esta [0], e = {top: 0, izquierda: 0}, f = d && d.ownerDocument; si (f) de retorno b = f.documentElement, n.contains (b, d) (typeof? this.map (function () {var A || Jc})}}), n.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, la función (b, c) {var d = "pageYOffset" === c; n.fn [ b] = function (e) {return J (esto, la función (b, e, f) {var g = Kc (b); vuelve vacía c (c = xb (a, b), vb.test (c) n (a) .position () [b] + "px":? c):? void f = arguments.length && (c || "booleano" = typeof d!), g = c || (d === 0 || e === 0 "margen":!? "frontera"); volver J (esto, la función (b, c, d) {var e; retorno ? 0 === d n.css (b, c, g):? N.style (b, c, d, g)}, b, f d: void 0, f, null)}})}), n.fn.size = function () {return this.length}, n.fn.andSelf = n.fn.addBack, "función" == definir typeof && && define.amd define ("jQuery", [], la función () {return n}); Lc var = a.jQuery, Mc = a $;. regresar n.noConflict = function (b) {return $ a === n && (a $ = Mc), b && a.jQuery === n &&.. (a.jQuery = Lc), n}, typeof b === U && (a.jQuery = a $ = n.), n});